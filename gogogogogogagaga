local FreeVersionTest = true

local Players = game:GetService('Players')
local UserInputService = game:GetService('UserInputService')
local CoreGuiService = game:GetService('CoreGui')
local HttpService = game:GetService('HttpService')

local Core = {
    Services = {
        Players = Players,
        UserInputService = UserInputService,
        CoreGuiService = CoreGuiService,
        Workspace = game:GetService('Workspace'),
        RunService = game:GetService('RunService'),
        ReplicatedStorage = game:GetService('ReplicatedStorage'),
        TweenService = game:GetService('TweenService'),
        FriendsList = {},
    },
    PlayerData = {
        LocalPlayer = Players.LocalPlayer,
        Camera = game.Workspace.CurrentCamera,
    },
    NotificationCooldown = { LastTime = 0, Delay = 5 },
    GradientColors = {
        Color1 = { Value = Color3.fromRGB(0, 0, 255) },
        Color2 = { Value = Color3.fromRGB(147, 112, 219) },
    },
    GunSilentTarget = {
        CurrentTarget = nil,
    },
    GlobalConfigs = {
        GradientColors = {
            ['Gradient Color 1'] = nil,
            ['Gradient Color 2'] = nil,
        },
        Rescale = {
            UseCustom = false,
            RescaleValue = 1.0,
        },
    },
    AttributeEncryption = {
        HashKey = nil,
        Cache = {},
    },
}

Core.GlobalConfigs.GradientColors['Gradient Color 1'] =
    Core.GradientColors.Color1.Value
Core.GlobalConfigs.GradientColors['Gradient Color 2'] =
    Core.GradientColors.Color2.Value

local CoreProxy = setmetatable({}, {
    __index = Core,
    __newindex = function() end,
})

local function logError(title, errorMsg, moduleName)
    local sanitizedError = tostring(errorMsg)
        :gsub('https?://[^%s]+', '[REDACTED]')
        :gsub('%[string ".-"%]', '[REDACTED]')
    local formattedMessage = string.format(
        'ðŸ’¥ | Error in %s: %s',
        moduleName or 'Unknown Module',
        sanitizedError
    )
    task.defer(function()
        if UI and UI.Window and UI.Window.Notify then
            UI.Window:Notify({
                Title = title,
                Description = formattedMessage,
                Lifetime = 5,
            })
        end
    end)
    warn(formattedMessage)
end

local function compute_djb2(str)
    local hash = 5381
    for i = 1, #str do
        hash = (hash * 33 + string.byte(str, i)) % 4294967296
    end
    return tostring(hash)
end

Core.GetEncryptedAttributeName = function(attr_name)
    if not Core.AttributeEncryption.HashKey then
        Core.AttributeEncryption.HashKey = Core.Services.Workspace:GetAttribute(
            'HashKey'
        ) or Core.Services.Workspace
            :GetAttributeChangedSignal('HashKey')
            :Wait()
    end
    if not Core.AttributeEncryption.Cache[attr_name] then
        local hash = compute_djb2(attr_name)
        local encrypted_name = Core.AttributeEncryption.HashKey .. hash
        Core.AttributeEncryption.Cache[attr_name] = encrypted_name
    end
    return Core.AttributeEncryption.Cache[attr_name]
end

local MacLib = loadstring(
    game:HttpGet(
        'https://github.com/biggaboy212/Maclib/releases/latest/download/maclib.txt',
        true
    )
)()
if not MacLib then
    error('Failed to load MacLib')
end

local UI = {
    Window = MacLib:Window({
        Title = 'Syllinse',
        Subtitle = 'Crashout V1',
        Size = UDim2.fromOffset(868, 650),
        DragStyle = 1,
        Keybind = Enum.KeyCode.RightControl,
        AcrylicBlur = false,
    }),
}

if not UI.Window then
    error('Failed to create UI Window')
end
local function notify(title, description, bypassCooldown)
    task.defer(function()
        if
            UI.Window
            and UI.Window.Notify
            and (
                bypassCooldown
                or tick() - Core.NotificationCooldown.LastTime
                    >= Core.NotificationCooldown.Delay
            )
        then
            UI.Window:Notify({
                Title = title,
                Description = description,
                Lifetime = 3,
            })
            Core.NotificationCooldown.LastTime = tick()
        end
    end)
end

local BASE_RESOLUTION = Vector2.new(1920, 1080)

local function rescaleUI()
    local camera = Core.Services.Workspace.CurrentCamera
    if not camera then
        return
    end

    local currentResolution = camera.ViewportSize
    local scale = Core.Services.UserInputService.TouchEnabled and 0.6
        or math.min(
            currentResolution.X / BASE_RESOLUTION.X,
            currentResolution.Y / BASE_RESOLUTION.Y
        )
    scale = math.min(scale, 1)

    if Core.GlobalConfigs.Rescale.UseCustom then
        scale = Core.GlobalConfigs.Rescale.RescaleValue
    end

    if UI.Window and type(UI.Window.SetScale) == 'function' then
        UI.Window:SetScale(scale)
    end
end

rescaleUI()
Core.Services.Workspace.CurrentCamera
    :GetPropertyChangedSignal('ViewportSize')
    :Connect(rescaleUI)

_G.SetUIScale = function(scale)
    if UI and UI.Window and type(UI.Window.SetScale) == 'function' then
        UI.Window:SetScale(scale)
    end
end

local function loadModule(moduleName, url)
    task.spawn(function()
        local success, result = pcall(function()
            return loadstring(game:HttpGet(url, true))()
        end)
        if not success then
            logError('Module Load', result, moduleName)
            return
        end
        if result and type(result) == 'table' and result.Init then
            local initSuccess, initError = pcall(function()
                result.Init(UI, CoreProxy, notify)
            end)
            if not initSuccess then
                logError('Module Init', initError, moduleName)
            end
        else
            logError(
                'Module Load',
                'Module did not return a valid table with Init function',
                moduleName
            )
        end
    end)
end

local function loadCrashoutModules()
    local modules = {
        {
            Name = 'Visuals',
            Url = 'https://raw.githubusercontent.com/pid123or123as/12345/refs/heads/main/VisualsV2-obfuscated.lua',
        },
        {
            Name = 'LocalPlayer',
            Url = 'https://raw.githubusercontent.com/Zenxxanlol2/kakkakey/refs/heads/main/local%20player',
        },
    }
    for _, module in ipairs(modules) do
        loadModule(module.Name, module.Url)
    end
end

MacLib:SetFolder('Syllinse')

UI.Tabs = { Main = UI.Window:TabGroup() }
UI.Tabs = {
    Visuals = UI.Tabs.Main:Tab({
        Name = 'Visuals',
        Image = 'rbxassetid://7992557358',
    }),
    Combat = UI.Tabs.Main:Tab({
        Name = 'Combat',
        Image = 'rbxassetid://4391741881',
    }),
    LocalPlayer = UI.Tabs.Main:Tab({
        Name = 'LocalPlayer',
        Image = 'rbxassetid://11570802781',
    }),
    Troll = UI.Tabs.Main:Tab({
        Name = 'Troll',
        Image = 'rbxassetid://111211548032129',
    }),
    Config = UI.Tabs.Main:Tab({
        Name = 'Settings',
        Image = 'rbxassetid://10734950309',
    }),
}

UI.Sections = {
    ItemESP = UI.Tabs.Visuals:Section({
        Name = 'Items ESP',
        Side = 'Right',
    }),
    PlayerESP = UI.Tabs.Visuals:Section({
        Name = 'ESP',
        Side = 'Right',
    }),
    Invisible = UI.Tabs.Combat:Section({
        Name = 'Invisible',
        Side = 'Left',
    }),
    Noclip = UI.Tabs.Combat:Section({
        Name = 'Noclip',
        Side = 'Right',
    }),
    SilentAim = UI.Tabs.Combat:Section({
        Name = 'Silent Aim',
        Side = 'Right',
    }),
    RageShoot = UI.Tabs.Combat:Section({
        Name = 'Rage Shoot',
        Side = 'Left',
    }),
    MenuButton = UI.Tabs.Visuals:Section({
        Name = 'Menu Button',
        Side = 'Left',
    }),
    Watermark = UI.Tabs.Visuals:Section({
        Name = 'Watermark',
        Side = 'Left',
    }),
    Timer = UI.Tabs.LocalPlayer:Section({
        Name = 'Timer',
        Side = 'Left',
    }),
    HighJumpReal = UI.Tabs.LocalPlayer:Section({
        Name = 'HighJump',
        Side = 'Right',
    }),
    Disabler = UI.Tabs.LocalPlayer:Section({
        Name = 'Disabler',
        Side = 'Right',
    }),
    Speed = UI.Tabs.LocalPlayer:Section({
        Name = 'Speed',
        Side = 'Right',
    }),
    TickSpeed = UI.Tabs.LocalPlayer:Section({
        Name = 'TickSpeed',
        Side = 'Left',
    }),
    Vehicle = UI.Tabs.Troll:Section({
        Name = 'Vehicle Troll',
        Side = 'Left',
    }),
    UI.Tabs.Config:InsertConfigSection({
        Name = 'Config System',
        Side = 'Left',
    }),
    loadCrashoutModules(),
}

task.defer(function()
    repeat
        task.wait()
    until UI and UI.Sections and UI.Tabs and UI.Tabs.LocalPlayer

    local LiftForce = 5
    local HighJumpEnabled = false
    local isHoldingJump = false
    local JumpConnection
    local StateConnection

    local Players = game:GetService('Players')
    local UIS = game:GetService('UserInputService')
    local RunService = game:GetService('RunService')
    local LocalPlayer = Players.LocalPlayer

    local function trackHumanoidJumpState(character)
        local humanoid = character:FindFirstChildOfClass('Humanoid')
        if not humanoid then
            return
        end

        if StateConnection then
            StateConnection:Disconnect()
        end

        StateConnection = humanoid.StateChanged:Connect(function(_, newState)
            if not HighJumpEnabled then
                return
            end

            if newState == Enum.HumanoidStateType.Jumping then
                isHoldingJump = true
            elseif
                newState == Enum.HumanoidStateType.Freefall
                or newState == Enum.HumanoidStateType.Seated
            then
                isHoldingJump = false
            end
        end)
    end

    UI.Sections.HighJumpReal:Header({ Name = 'HighJump' })

    UI.Sections.HighJumpReal:Toggle({
        Name = 'Enable HighJump',
        Default = false,
        Callback = function(state)
            HighJumpEnabled = state

            if JumpConnection then
                JumpConnection:Disconnect()
                JumpConnection = nil
            end

            if StateConnection then
                StateConnection:Disconnect()
                StateConnection = nil
            end

            if state then
                trackHumanoidJumpState(
                    LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                )
                LocalPlayer.CharacterAdded:Connect(trackHumanoidJumpState)

                JumpConnection = RunService.RenderStepped:Connect(function()
                    if not HighJumpEnabled or not isHoldingJump then
                        return
                    end

                    local char = LocalPlayer.Character
                    local hrp = char and char:FindFirstChild('HumanoidRootPart')
                    local humanoid = char
                        and char:FindFirstChildOfClass('Humanoid')

                    if
                        humanoid
                        and humanoid.SeatPart
                        and humanoid.SeatPart:IsA('VehicleSeat')
                    then
                        return
                    end

                    if hrp then
                        hrp.Velocity = Vector3.new(
                            hrp.Velocity.X,
                            LiftForce * 10,
                            hrp.Velocity.Z
                        )
                    end
                end)
            end
        end,
    }, 'EnableHighJump')

    UIS.InputBegan:Connect(function(input, processed)
        if processed then
            return
        end

        if input.KeyCode == Enum.KeyCode.Space then
            isHoldingJump = true
        elseif
            input.KeyCode == Enum.KeyCode.ButtonA
            or input.KeyCode == Enum.KeyCode.Thumbstick1
            or input.UserInputType == Enum.UserInputType.Touch
        then
            isHoldingJump = true
        end
    end)

    UIS.InputEnded:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.Space then
            isHoldingJump = false
        elseif
            input.KeyCode == Enum.KeyCode.ButtonA
            or input.KeyCode == Enum.KeyCode.Thumbstick1
            or input.UserInputType == Enum.UserInputType.Touch
        then
            isHoldingJump = false
        end
    end)
end)

local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer
local CoreGui = game:GetService('CoreGui')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')

local Inventory = require(ReplicatedStorage.Values.Inventory)
local Images = require(ReplicatedStorage.Values.Images)

local CurrentTarget = nil

local ScreenGui = Instance.new('ScreenGui')
ScreenGui.Name = 'TargetInventoryESP'
ScreenGui.IgnoreGuiInset = true
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = CoreGui
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local MainContainer = Instance.new('Frame')
MainContainer.Size = UDim2.new(0, 220, 0, 260)
MainContainer.Position = UDim2.new(0.3, 0, 0.25, 0)
MainContainer.BackgroundColor3 = Color3.fromRGB(20, 30, 50)
MainContainer.BackgroundTransparency = 0.3
MainContainer.BorderSizePixel = 0
MainContainer.Parent = ScreenGui

local MainCorner = Instance.new('UICorner')
MainCorner.CornerRadius = UDim.new(0, 12)
MainCorner.Parent = MainContainer

local Header = Instance.new('Frame')
Header.Size = UDim2.new(1, 0, 0, 35)
Header.BackgroundTransparency = 0.3
Header.BackgroundColor3 = Color3.fromRGB(20, 30, 50)
Header.BorderSizePixel = 0
Header.Parent = MainContainer

local HeaderCorner = Instance.new('UICorner')
HeaderCorner.CornerRadius = UDim.new(0, 12)
HeaderCorner.Parent = Header

local iconLabel = Instance.new('ImageLabel')
iconLabel.Size = UDim2.new(0, 20, 0, 20)
iconLabel.Position = UDim2.new(0, 10, 0, 5)
iconLabel.BackgroundTransparency = 1
iconLabel.Image = 'rbxassetid://15016878198'
iconLabel.ImageColor3 = Color3.fromRGB(240, 240, 240)
iconLabel.Parent = Header

local titleLabel = Instance.new('TextLabel')
titleLabel.Size = UDim2.new(1, -35, 1, -10)
titleLabel.Position = UDim2.new(0, 35, 0, 5)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = 'Target Inventory'
titleLabel.TextColor3 = Color3.fromRGB(240, 240, 240)
titleLabel.TextSize = 18
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = Header

local nickLabel = Instance.new('TextLabel')
nickLabel.Size = UDim2.new(1, -20, 0, 25)
nickLabel.Position = UDim2.new(0, 10, 0, 40)
nickLabel.BackgroundTransparency = 1
nickLabel.Text = ''
nickLabel.TextColor3 = Color3.fromRGB(240, 240, 240)
nickLabel.TextSize = 16
nickLabel.Font = Enum.Font.GothamBold
nickLabel.TextXAlignment = Enum.TextXAlignment.Center
nickLabel.Parent = MainContainer

local equippedFrame = Instance.new('Frame')
equippedFrame.Size = UDim2.new(1, -20, 0, 40)
equippedFrame.Position = UDim2.new(0, 10, 0, 70)
equippedFrame.BackgroundTransparency = 1
equippedFrame.Parent = MainContainer

local equippedIcon = Instance.new('ImageLabel')
equippedIcon.Size = UDim2.new(0, 30, 0, 30)
equippedIcon.Position = UDim2.new(0, 0, 0, 5)
equippedIcon.BackgroundTransparency = 1
equippedIcon.Parent = equippedFrame

local equippedLabel = Instance.new('TextLabel')
equippedLabel.Size = UDim2.new(1, -35, 0, 30)
equippedLabel.Position = UDim2.new(0, 35, 0, 5)
equippedLabel.BackgroundTransparency = 1
equippedLabel.Text = 'Equipped :None'
equippedLabel.TextColor3 = Color3.fromRGB(240, 240, 240)
equippedLabel.TextSize = 16
equippedLabel.Font = Enum.Font.GothamBold
equippedLabel.TextXAlignment = Enum.TextXAlignment.Left
equippedLabel.Parent = equippedFrame

local backpackFrame = Instance.new('ScrollingFrame')
backpackFrame.Size = UDim2.new(1, -20, 0, 130)
backpackFrame.Position = UDim2.new(0, 10, 0, 115)
backpackFrame.BackgroundTransparency = 1
backpackFrame.BorderSizePixel = 0
backpackFrame.ScrollBarThickness = 6
backpackFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
backpackFrame.ScrollBarImageColor3 = Color3.fromRGB(200, 200, 200)
backpackFrame.Parent = MainContainer

local backpackLayout = Instance.new('UIGridLayout')
backpackLayout.CellSize = UDim2.new(0, 50, 0, 60)
backpackLayout.CellPadding = UDim2.new(0, 6, 0, 6)
backpackLayout.SortOrder = Enum.SortOrder.LayoutOrder
backpackLayout.FillDirectionMaxCells = 4
backpackLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
backpackLayout.VerticalAlignment = Enum.VerticalAlignment.Top
backpackLayout.Parent = backpackFrame

backpackFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y

local function getToolIcon(tool)
    local data = Inventory[tool.Name]
    if data and data.Image and data.Image ~= '' then
        return data.Image
    end
    if tool.TextureId and tool.TextureId ~= '' then
        return tool.TextureId
    end
    return ''
end

local function getToolColor(tool)
    local data = Inventory[tool.Name]
    if data and data.Rarity then
        local idx = tonumber(data.Rarity)
        if idx and Images.Colours[idx] then
            return Images.Colours[idx]
        end
    end
    return Color3.fromRGB(255, 255, 255)
end

local LastBackpack = {}
local LastEquipped = nil

local function updateInventory(plr)
    if not plr or not plr.Character or not plr.Backpack then
        MainContainer.Visible = false
        return
    end

    nickLabel.Text = plr.Name

    local equippedTool = plr.Character:FindFirstChildOfClass('Tool')
    if equippedTool and equippedTool.Name ~= 'Fists' then
        if LastEquipped ~= equippedTool then
            equippedLabel.Text = 'Equipped: ' .. equippedTool.Name
            equippedLabel.TextColor3 = getToolColor(equippedTool)
            equippedIcon.Image = getToolIcon(equippedTool)
            equippedIcon.BackgroundColor3 = getToolColor(equippedTool)
            equippedIcon.BackgroundTransparency = 0

            if not equippedIcon:FindFirstChildOfClass('UICorner') then
                local corner = Instance.new('UICorner')
                corner.CornerRadius = UDim.new(0.5, 0)
                corner.Parent = equippedIcon
            end

            LastEquipped = equippedTool
        end
    else
        if LastEquipped ~= nil then
            equippedLabel.Text = 'Equipped: None'
            equippedLabel.TextColor3 = Color3.fromRGB(240, 240, 240)
            equippedIcon.Image = ''
            equippedIcon.BackgroundTransparency = 1
            LastEquipped = nil
        end
    end

    local currentBackpack = {}
    for _, tool in ipairs(plr.Backpack:GetChildren()) do
        if tool.Name ~= 'Fists' then
            table.insert(currentBackpack, tool.Name)
        end
    end

    local changed = false
    if #currentBackpack ~= #LastBackpack then
        changed = true
    else
        for i = 1, #currentBackpack do
            if currentBackpack[i] ~= LastBackpack[i] then
                changed = true
                break
            end
        end
    end

    if changed then
        for _, child in ipairs(backpackFrame:GetChildren()) do
            if child:IsA('Frame') then
                child:Destroy()
            end
        end

        for _, tool in ipairs(plr.Backpack:GetChildren()) do
            if tool.Name ~= 'Fists' then
                local icon = getToolIcon(tool)
                local color = getToolColor(tool)
                if icon ~= '' then
                    local frame = Instance.new('Frame')
                    frame.Size = UDim2.new(0, 50, 0, 60)
                    frame.BackgroundTransparency = 1
                    frame.Parent = backpackFrame

                    local circle = Instance.new('Frame')
                    circle.Size = UDim2.new(0.9, 0, 0.6, 0)
                    circle.Position = UDim2.new(0.05, 0, 0, 0)
                    circle.BackgroundColor3 = color
                    circle.BorderSizePixel = 0
                    circle.Parent = frame
                    local corner = Instance.new('UICorner')
                    corner.CornerRadius = UDim.new(0.5, 0)
                    corner.Parent = circle

                    local img = Instance.new('ImageLabel')
                    img.Size = UDim2.new(0.8, 0, 0.6, 0)
                    img.Position = UDim2.new(0.1, 0, 0, 0)
                    img.BackgroundTransparency = 1
                    img.Image = icon
                    img.Parent = frame

                    local label = Instance.new('TextLabel')
                    label.Size = UDim2.new(1, 0, 0, 16)
                    label.Position = UDim2.new(0, 0, 0.65, 0)
                    label.BackgroundTransparency = 1
                    label.Text = tool.Name
                    label.TextColor3 = color
                    label.TextSize = 12
                    label.Font = Enum.Font.GothamBold
                    label.TextXAlignment = Enum.TextXAlignment.Center
                    label.TextScaled = true
                    label.Parent = frame
                end
            end
        end

        backpackFrame.CanvasSize =
            UDim2.new(0, 0, 0, backpackLayout.AbsoluteContentSize.Y)

        LastBackpack = currentBackpack
    end
end

local dragging = false
local dragInput, dragStart, startPos
local function updatePosition(input)
    local delta = input.Position - dragStart
    MainContainer.Position = UDim2.new(
        startPos.X.Scale,
        startPos.X.Offset + delta.X,
        startPos.Y.Scale,
        startPos.Y.Offset + delta.Y
    )
end

Header.InputBegan:Connect(function(input)
    if
        input.UserInputType == Enum.UserInputType.MouseButton1
        or input.UserInputType == Enum.UserInputType.Touch
    then
        dragging = true
        dragStart = input.Position
        startPos = MainContainer.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

Header.InputChanged:Connect(function(input)
    if
        input.UserInputType == Enum.UserInputType.MouseMovement
        or input.UserInputType == Enum.UserInputType.Touch
    then
        dragInput = input
    end
end)

RunService.RenderStepped:Connect(function()
    if dragging and dragInput then
        updatePosition(dragInput)
    end
end)

backpackFrame.ScrollingEnabled = false

backpackFrame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseWheel then
        local newPos = backpackFrame.CanvasPosition.Y - (input.Position.Z * 40)
        local maxPos = backpackFrame.AbsoluteCanvasSize.Y
            - backpackFrame.AbsoluteSize.Y
        backpackFrame.CanvasPosition =
            Vector2.new(0, math.clamp(newPos, 0, math.max(maxPos, 0)))
    end
end)

local dragging = false
local startY = 0
local startCanvasY = 0

backpackFrame.InputBegan:Connect(function(input)
    if
        input.UserInputType == Enum.UserInputType.MouseButton1
        or input.UserInputType == Enum.UserInputType.Touch
    then
        dragging = true
        startY = input.Position.Y
        startCanvasY = backpackFrame.CanvasPosition.Y
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if
        input.UserInputType == Enum.UserInputType.MouseButton1
        or input.UserInputType == Enum.UserInputType.Touch
    then
        dragging = false
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if
        dragging
        and (
            input.UserInputType == Enum.UserInputType.MouseMovement
            or input.UserInputType == Enum.UserInputType.Touch
        )
    then
        local delta = input.Position.Y - startY
        local newPos = startCanvasY - delta
        local maxPos = backpackFrame.AbsoluteCanvasSize.Y
            - backpackFrame.AbsoluteSize.Y
        backpackFrame.CanvasPosition =
            Vector2.new(0, math.clamp(newPos, 0, math.max(maxPos, 0)))
    end
end)

local function getClosestPlayer()
    local camera = workspace.CurrentCamera
    local mousePos
    if UserInputService.TouchEnabled and not UserInputService.MouseEnabled then
        mousePos =
            Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    else
        mousePos =
            Vector2.new(LocalPlayer:GetMouse().X, LocalPlayer:GetMouse().Y)
    end

    local closest = nil
    local closestDist = math.huge

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character then
            local hrp = plr.Character:FindFirstChild('HumanoidRootPart')
            local humanoid = plr.Character:FindFirstChild('Humanoid')
            if hrp and humanoid and humanoid.Health > 0 then
                local screenPos, onScreen =
                    camera:WorldToScreenPoint(hrp.Position)
                if onScreen then
                    local dist = (mousePos - Vector2.new(
                        screenPos.X,
                        screenPos.Y
                    )).Magnitude
                    if dist <= 20 and dist < closestDist then
                        closestDist = dist
                        closest = plr
                    end
                end
            end
        end
    end

    return closest
end

RunService.RenderStepped:Connect(function()
    if not ItemESPEnabled then
        if MainContainer.Visible then
            MainContainer.Visible = false
            CurrentTarget = nil
        end
        return
    end

    local target = getClosestPlayer()

    if target ~= CurrentTarget then
        CurrentTarget = target
        if target then
            updateInventory(target)
            MainContainer.Visible = true
        end
    end

    if not target and CurrentTarget then
        nickLabel.Text = 'No target in FOV'
        equippedLabel.Text = 'Equipped: None'
        equippedIcon.Image = ''
        equippedIcon.BackgroundTransparency = 1
    end
end)

task.defer(function()
    repeat
        task.wait()
    until UI and UI.Tabs and UI.Tabs.Visuals

    UI.Sections.ItemESP:Header({ Name = 'Inventory ESP' })
    UI.Sections.ItemESP:Toggle({
        Name = 'Inventory ESP',
        Default = false,
        Callback = function(value)
            ItemESPEnabled = value
            MainContainer.Visible = value
            if not value then
                CurrentTarget = nil
            end
        end,
    })
end)

local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local LocalPlayer = Players.LocalPlayer

local PlayerESPEnabled = false
local BoxFillEnabled = false
local ChamsEnabled = false

local ESPColor = Color3.fromRGB(255, 255, 255)
local ChamsColor = Color3.fromRGB(0, 255, 255)

local function ApplyChams(player)
    if not player.Character then
        return
    end
    local highlight = player.Character:FindFirstChildOfClass('Highlight')
    if not highlight then
        highlight = Instance.new('Highlight')
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Parent = player.Character
    end
    highlight.FillColor = ChamsColor
    highlight.OutlineColor = Color3.new(0, 0, 0)
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
end

local function RemoveChams(player)
    if player.Character then
        for _, v in ipairs(player.Character:GetChildren()) do
            if v:IsA('Highlight') then
                v:Destroy()
            end
        end
    end
end

function CreateEsp(Player)
    local Box = Drawing.new('Square')
    local BoxOutline = Drawing.new('Square')
    local BoxFill = Drawing.new('Square')
    local Name = Drawing.new('Text')
    local HealthBar = Drawing.new('Square')
    local HealthBarOutline = Drawing.new('Square')

    RunService.RenderStepped:Connect(function()
        if not PlayerESPEnabled then
            Box.Visible = false
            BoxOutline.Visible = false
            BoxFill.Visible = false
            Name.Visible = false
            HealthBar.Visible = false
            HealthBarOutline.Visible = false
            return
        end

        if
            Player.Character
            and Player.Character:FindFirstChild('Humanoid')
            and Player.Character:FindFirstChild('HumanoidRootPart')
            and Player.Character.Humanoid.Health > 0
            and Player.Character:FindFirstChild('Head')
        then
            local Target2dPosition, IsVisible =
                workspace.CurrentCamera:WorldToViewportPoint(
                    Player.Character.HumanoidRootPart.Position
                )
            local scale_factor = 1
                / (Target2dPosition.Z * math.tan(
                    math.rad(workspace.CurrentCamera.FieldOfView * 0.5)
                ) * 2)
                * 100
            local width, height =
                math.floor(40 * scale_factor), math.floor(60 * scale_factor)

            Box.Visible = IsVisible
            Box.Color = ESPColor
            Box.Size = Vector2.new(width, height)
            Box.Position = Vector2.new(
                Target2dPosition.X - width / 2,
                Target2dPosition.Y - height / 2
            )
            Box.Thickness = 1
            Box.ZIndex = 69

            BoxOutline.Visible = IsVisible
            BoxOutline.Color = Color3.fromRGB(0, 0, 0)
            BoxOutline.Size = Box.Size
            BoxOutline.Position = Box.Position
            BoxOutline.Thickness = 3
            BoxOutline.ZIndex = 1

            BoxFill.Visible = BoxFillEnabled and IsVisible
            BoxFill.Color = ESPColor
            BoxFill.Size = Box.Size
            BoxFill.Position = Box.Position
            BoxFill.Transparency = 0.3
            BoxFill.Filled = true

            Name.Visible = IsVisible
            Name.Color = ESPColor
            Name.Text = Player.Name
                .. ' '
                .. math.floor(
                    (
                        workspace.CurrentCamera.CFrame.p
                        - Player.Character.HumanoidRootPart.Position
                    ).Magnitude
                )
                .. 'm'
            Name.Center = true
            Name.Outline = true
            Name.OutlineColor = Color3.fromRGB(0, 0, 0)
            Name.Position = Vector2.new(
                Target2dPosition.X,
                Target2dPosition.Y - height * 0.5 - 15
            )
            Name.Font = 2
            Name.Size = 13

            HealthBarOutline.Visible = IsVisible
            HealthBarOutline.Color = Color3.fromRGB(0, 0, 0)
            HealthBarOutline.Filled = true
            HealthBarOutline.ZIndex = 1
            HealthBarOutline.Size = Vector2.new(2, height)
            HealthBarOutline.Position = Vector2.new(
                Target2dPosition.X - width / 2 - 3,
                Target2dPosition.Y - height / 2
            )

            HealthBar.Visible = IsVisible
            HealthBar.Color = Color3.fromRGB(255, 0, 0):Lerp(
                Color3.fromRGB(0, 255, 0),
                Player.Character.Humanoid.Health
                    / Player.Character.Humanoid.MaxHealth
            )
            HealthBar.Thickness = 1
            HealthBar.Filled = true
            HealthBar.ZIndex = 69
            HealthBar.Size = Vector2.new(
                1,
                -(HealthBarOutline.Size.Y - 2)
                    * (
                        Player.Character.Humanoid.Health
                        / Player.Character.Humanoid.MaxHealth
                    )
            )
            HealthBar.Position = HealthBarOutline.Position
                + Vector2.new(1, -1 + HealthBarOutline.Size.Y)

            if ChamsEnabled then
                ApplyChams(Player)
            else
                RemoveChams(Player)
            end
        else
            Box.Visible = false
            BoxOutline.Visible = false
            BoxFill.Visible = false
            Name.Visible = false
            HealthBar.Visible = false
            HealthBarOutline.Visible = false
        end
    end)
end

for _, v in pairs(Players:GetPlayers()) do
    if v ~= LocalPlayer then
        CreateEsp(v)
        v.CharacterAdded:Connect(function()
            CreateEsp(v)
        end)
    end
end

Players.PlayerAdded:Connect(function(v)
    if v ~= LocalPlayer then
        CreateEsp(v)
        v.CharacterAdded:Connect(function()
            CreateEsp(v)
        end)
    end
end)

task.defer(function()
    repeat
        task.wait()
    until UI and UI.Tabs and UI.Tabs.Visuals
    UI.Sections.PlayerESP:Header({ Name = 'ESP Settings' })
    UI.Sections.PlayerESP:Toggle({
        Name = 'Player ESP',
        Default = false,
        Callback = function(value)
            PlayerESPEnabled = value
        end,
    })
    UI.Sections.PlayerESP:Toggle({
        Name = 'Box Fill',
        Default = false,
        Callback = function(value)
            BoxFillEnabled = value
        end,
    })
    UI.Sections.PlayerESP:Colorpicker({
        Name = 'ESP Box Color',
        Default = ESPColor,
        Callback = function(color)
            ESPColor = color
        end,
    })
    UI.Sections.PlayerESP:Toggle({
        Name = 'Chams',
        Default = false,
        Callback = function(value)
            ChamsEnabled = value
            for _, v in pairs(Players:GetPlayers()) do
                if v ~= LocalPlayer then
                    if value then
                        ApplyChams(v)
                    else
                        RemoveChams(v)
                    end
                end
            end
        end,
    })
    UI.Sections.PlayerESP:Colorpicker({
        Name = 'Chams Color',
        Default = ChamsColor,
        Callback = function(color)
            ChamsColor = color
            if ChamsEnabled then
                for _, v in pairs(Players:GetPlayers()) do
                    if
                        v ~= LocalPlayer
                        and v.Character
                        and v.Character:FindFirstChildOfClass('Highlight')
                    then
                        v.Character:FindFirstChildOfClass('Highlight').FillColor =
                            color
                    end
                end
            end
        end,
    })
end)

local RunService = game:GetService('RunService')
local Players = game:GetService('Players')
local player = Players.LocalPlayer

local toggleActive = false
local lastPosition = nil
local threshold = 10

RunService.Stepped:Connect(function()
    if
        toggleActive
        and player.Character
        and player.Character:FindFirstChild('HumanoidRootPart')
    then
        local char = player.Character
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA('BasePart') then
                part.CanCollide = false
            end
        end

        local hrp = char:FindFirstChild('HumanoidRootPart')
        if hrp then
            local currentPos = hrp.Position
            if lastPosition then
                local distance = (currentPos - lastPosition).Magnitude
                if distance > threshold then
                    hrp.CFrame = CFrame.new(lastPosition)
                else
                    lastPosition = currentPos
                end
            else
                lastPosition = currentPos
            end
        end
    end
end)

task.defer(function()
    repeat
        task.wait()
    until UI and UI.Tabs and UI.Tabs.Combat

    UI.Sections.Noclip:Header({ Name = 'Noclip' })
    UI.Sections.Noclip:Toggle({
        Name = 'Noclip',
        Default = false,
        Callback = function(value)
            toggleActive = value
            if not toggleActive then
                if player.Character then
                    for _, part in pairs(player.Character:GetDescendants()) do
                        if part:IsA('BasePart') then
                            part.CanCollide = true
                        end
                    end
                end
                lastPosition = nil
            end
        end,
    })
end)

local replicated_storage = game:GetService('ReplicatedStorage')
local players = game:GetService('Players')
local workspace = game:GetService('Workspace')
local run_service = game:GetService('RunService')

local camera = workspace.CurrentCamera
local utility = require(replicated_storage.Modules.Packages.Icon.Utility)

if not workspace:FindFirstChild('WL') then
    local wl = Instance.new('Folder')
    wl.Name = 'WL'
    wl.Parent = workspace
end

getgenv().SilentAimEnabled = false
getgenv().TrajectoryBeam = false
getgenv().FOV = 100
getgenv().MaxDistance = 200
getgenv().Wallbang = false
getgenv().ShowFOV = false

local beamPart = Instance.new('Part')
beamPart.Name = 'SilentAimBeamPart'
beamPart.Anchored = true
beamPart.CanCollide = false
beamPart.Transparency = 1
beamPart.Size = Vector3.new(0.1, 0.1, 0.1)
beamPart.Parent = workspace

local attachment0 = Instance.new('Attachment', beamPart)
local attachment1 = Instance.new('Attachment')
attachment1.Parent = beamPart

local beam = Instance.new('Beam')
beam.Attachment0 = attachment0
beam.Attachment1 = attachment1
beam.Width0 = 0.1
beam.Width1 = 0.1
beam.Color = ColorSequence.new(Color3.new(1, 0, 0))
beam.Transparency = NumberSequence.new(0)
beam.FaceCamera = true
beam.LightEmission = 1
beam.Enabled = false
beam.Parent = beamPart

local circle = Drawing.new('Circle')
circle.Visible = getgenv().ShowFOV
circle.Radius = getgenv().FOV
circle.Color = Color3.new(1, 0, 0)
circle.Thickness = 2
circle.Filled = false
circle.Position =
    Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)

local function get_players()
    local entities = {}
    for _, player in ipairs(players:GetPlayers()) do
        if player ~= players.LocalPlayer and player.Character then
            local humanoid = player.Character:FindFirstChildOfClass('Humanoid')
            local rootPart = player.Character:FindFirstChild('HumanoidRootPart')
            if humanoid and humanoid.Health > 0 and rootPart then
                table.insert(entities, player.Character)
            end
        end
    end
    for _, child in workspace:GetChildren() do
        if
            child:FindFirstChildOfClass('Humanoid')
            and not players:GetPlayerFromCharacter(child)
        then
            local humanoid = child:FindFirstChildOfClass('Humanoid')
            if humanoid and humanoid.Health > 0 then
                table.insert(entities, child)
            end
        end
    end
    return entities
end

local function get_closest_player()
    local closest, closest_distance = nil, math.huge
    local character = players.LocalPlayer.Character
    if not character or not character:FindFirstChild('HumanoidRootPart') then
        return nil
    end
    local localPos = character.HumanoidRootPart.Position
    for _, entity in ipairs(get_players()) do
        if
            not entity:FindFirstChild('HumanoidRootPart')
            or not entity:FindFirstChild('Head')
        then
            continue
        end
        local targetPos = entity.HumanoidRootPart.Position
        local distance = (localPos - targetPos).Magnitude
        if distance > getgenv().MaxDistance then
            continue
        end
        local screenPos, onScreen = camera:WorldToViewportPoint(targetPos)
        if onScreen then
            local center = Vector2.new(
                camera.ViewportSize.X / 2,
                camera.ViewportSize.Y / 2
            )
            local mousePos = Vector2.new(screenPos.X, screenPos.Y)
            local distance2D = (center - mousePos).Magnitude
            if
                distance2D <= getgenv().FOV
                and distance2D < closest_distance
            then
                closest = entity
                closest_distance = distance2D
            end
        end
    end
    return closest
end

local raycastModule = require(
    replicated_storage.Modules.Client.Controllers.ToolController.Gun.Raycast
)
local inventoryModule = require(replicated_storage.Values.Inventory)
local partToBodyModule = require(replicated_storage.Modules.Utils.PartToBody)

local originalRaycast = raycastModule.Raycast
raycastModule.Raycast = function(slotValue)
    local hitPart, hitPosition, hitNormal, material, humanoid =
        originalRaycast(slotValue)
    if getgenv().SilentAimEnabled then
        local closest = get_closest_player()
        if closest and closest:FindFirstChild('Head') then
            local head = closest.Head
            local headPosition = head.Position
            local char = players.LocalPlayer.Character
            local tool = char and char:FindFirstChildOfClass('Tool')
            local muzzle = tool and tool:FindFirstChild('Muzzle')
            if muzzle then
                local direction = (headPosition - muzzle.Position).Unit
                local distance = (headPosition - muzzle.Position).Magnitude
                if not getgenv().Wallbang then
                    local raycastParams = RaycastParams.new()
                    raycastParams.FilterDescendantsInstances = { char, closest }
                    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                    local rayResult = workspace:Raycast(
                        muzzle.Position,
                        direction * distance,
                        raycastParams
                    )
                    if
                        rayResult
                        and rayResult.Instance
                        and not closest:IsAncestorOf(rayResult.Instance)
                    then
                        return hitPart,
                            hitPosition,
                            hitNormal,
                            material,
                            humanoid
                    end
                end

                local fakeHitPosition = headPosition - (direction * 0.5)
                return head,
                    fakeHitPosition,
                    -direction,
                    head.Material,
                    closest:FindFirstChildOfClass('Humanoid')
            end
        end
    end
    return hitPart, hitPosition, hitNormal, material, humanoid
end

run_service.RenderStepped:Connect(function()
    circle.Visible = getgenv().ShowFOV
    circle.Position =
        Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    circle.Radius = getgenv().FOV

    if not (getgenv().SilentAimEnabled and getgenv().TrajectoryBeam) then
        beam.Enabled = false
        return
    end

    local char = players.LocalPlayer.Character
    local tool = char and char:FindFirstChildOfClass('Tool')
    local originPart = tool
            and (tool:FindFirstChild('Muzzle') or tool:FindFirstChild('Handle'))
        or (char and char:FindFirstChild('Head'))
    local closest = get_closest_player()

    if originPart and closest and closest:FindFirstChild('Head') then
        local origin = originPart.Position
        local target = closest.Head.Position
        beamPart.Position = origin
        attachment0.WorldPosition = origin
        attachment1.WorldPosition = target
        beam.Enabled = true
    else
        beam.Enabled = false
    end
end)

task.defer(function()
    repeat
        task.wait()
    until UI and UI.Tabs and UI.Tabs.Combat

    UI.Sections.SilentAim:Header({ Name = 'Silent Aim Options' })
    UI.Sections.SilentAim:Toggle({
        Name = 'Enable Silent Aim',
        Default = false,
        Callback = function(value)
            getgenv().SilentAimEnabled = value
        end,
    }, 'SilentAimToggle')

    UI.Sections.SilentAim:Toggle({
        Name = 'WallBang',
        Default = false,
        Callback = function(value)
            getgenv().Wallbang = value
        end,
    }, 'WallbangToggle')

    UI.Sections.SilentAim:Slider({
        Name = 'Max Distance',
        Default = 200,
        Minimum = 50,
        Maximum = 1000,
        DisplayMethod = 'Value',
        Precision = 0,
        Callback = function(Value)
            getgenv().MaxDistance = Value
        end,
    }, 'DistanceSlider')

    UI.Sections.SilentAim:Slider({
        Name = 'FOV Radius',
        Default = 100,
        Minimum = 10,
        Maximum = 500,
        DisplayMethod = 'Value',
        Precision = 0,
        Callback = function(Value)
            getgenv().FOV = Value
            if circle then
                circle.Radius = Value
            end
        end,
    }, 'FOVSlider')

    UI.Sections.SilentAim:Toggle({
        Name = 'Show FOV',
        Default = false,
        Callback = function(value)
            getgenv().ShowFOV = value
            if circle then
                circle.Visible = value
            end
        end,
    }, 'ShowFOVToggle')

    UI.Sections.SilentAim:Header({ Name = 'Beam Options' })
    UI.Sections.SilentAim:Toggle({
        Name = 'Show Trajectory Beam',
        Default = false,
        Callback = function(value)
            getgenv().TrajectoryBeam = value
        end,
    }, 'BeamToggle')

    UI.Sections.SilentAim:Colorpicker({
        Name = 'Beam Color',
        Default = Color3.fromRGB(255, 0, 0),
        Callback = function(color)
            if beam then
                beam.Color = ColorSequence.new(color)
            end
        end,
    }, 'BeamColorPicker')
end)

local shotgunModule = require(
    replicated_storage.Modules.Client.Controllers.ToolController.Gun.FireTypes.Shotgun
)
local originalShotgunShoot = shotgunModule.OnShoot

shotgunModule.OnShoot = function(toolModule) -- renamed param to clarify
    local char = players.LocalPlayer.Character
    local toolInstance = char and char:FindFirstChildOfClass('Tool') -- get actual instance
    if not toolInstance then
        return originalShotgunShoot(toolModule)
    end

    local slotValue = toolModule.GetCurrentSlot().Value
    local pelletAmount = inventoryModule[slotValue].PelletAmount
    if not pelletAmount then
        error('PelletAmount not set in inventory module!')
    end

    local hits = {}
    for _ = 1, pelletAmount do
        local spread = Vector3.new(
            math.random(-20, 20) / 200,
            math.random(-20, 20) / 200,
            math.random(-20, 20) / 200
        )

        if getgenv().SilentAimEnabled then
            local closest = get_closest_player()
            if closest and closest:FindFirstChild('Head') then
                local muzzle = toolInstance:FindFirstChild('Muzzle')
                    or toolInstance:FindFirstChild('Handle')
                if muzzle then
                    local direction = (closest.Head.Position - muzzle.Position).Unit
                    spread = -direction
                end
            end
        end

        local hitPart, hitPos, hitNormal, material, humanoid =
            require(raycastModule).Raycast(slotValue, spread)

        if humanoid then
            require(
                replicated_storage.Modules.Client.Controllers.ToolController.Gun.Visulise
            ):Blood(
                hitPos,
                hitNormal,
                humanoid,
                inventoryModule[slotValue].Damages[partToBodyModule(
                    humanoid.Parent,
                    hitPart
                )]
            )
        elseif hitPart then
            require(
                replicated_storage.Modules.Client.Controllers.ToolController.Gun.Visulise
            ):BulletHole(hitPos, hitNormal, material, hitPart)
        end

        require(
            replicated_storage.Modules.Client.Controllers.ToolController.Gun.Visulise
        ):Tracer(toolInstance.Muzzle.Position, hitPos)
        table.insert(hits, { hitPart, hitPos, hitNormal, material })
    end

    require(replicated_storage.Modules.Packages.Net)
        :RemoteEvent('GunRemote')
        :FireServer('Shoot', hits)
end

local Players = game:GetService('Players')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')
local Debris = game:GetService('Debris')
local camera = workspace.CurrentCamera

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild('HumanoidRootPart')

player.CharacterAdded:Connect(function(char)
    character = char
    rootPart = char:WaitForChild('HumanoidRootPart')
end)

local REGunRemote =
    ReplicatedStorage.Modules.Packages._Index['sleitnick_net@0.2.0'].net['RE/GunRemote']

getgenv().AUTO_SHOOT = false
getgenv().FOV_VISIBLE = false
getgenv().FOV_SIZE = 250
getgenv().MAX_DISTANCE = 1000
getgenv().AUTO_SHOOT_RATE = 0.1

local function makeBeam(origin, target, color)
    local p0 = Instance.new('Part')
    p0.Anchored = true
    p0.CanCollide = false
    p0.Transparency = 1
    p0.Size = Vector3.new(0.2, 0.2, 0.2)
    p0.CFrame = CFrame.new(origin)
    p0.Parent = workspace

    local p1 = Instance.new('Part')
    p1.Anchored = true
    p1.CanCollide = false
    p1.Transparency = 1
    p1.Size = Vector3.new(0.2, 0.2, 0.2)
    p1.CFrame = CFrame.new(target)
    p1.Parent = workspace

    local a0 = Instance.new('Attachment', p0)
    local a1 = Instance.new('Attachment', p1)
    local beam = Instance.new('Beam')
    beam.Attachment0 = a0
    beam.Attachment1 = a1
    beam.Color = ColorSequence.new(color or Color3.fromRGB(255, 0, 0))
    beam.Width0 = 0.1
    beam.Width1 = 0.1
    beam.FaceCamera = true
    beam.Parent = p0

    Debris:AddItem(p0, 0.2)
    Debris:AddItem(p1, 0.2)
end

local fovCircle = Drawing.new('Circle')
fovCircle.Visible = getgenv().FOV_VISIBLE
fovCircle.Thickness = 2
fovCircle.Color = Color3.fromRGB(255, 0, 0)
fovCircle.Transparency = 1
fovCircle.NumSides = 64
fovCircle.Radius = getgenv().FOV_SIZE
fovCircle.Filled = false

RunService.RenderStepped:Connect(function()
    if camera then
        fovCircle.Position =
            Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
        fovCircle.Visible = getgenv().FOV_VISIBLE
        fovCircle.Radius = getgenv().FOV_SIZE
    end
end)

local function isInFOV(pos)
    local screenPoint, onScreen = camera:WorldToScreenPoint(pos)
    if not onScreen then
        return false
    end
    local center =
        Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    return (Vector2.new(screenPoint.X, screenPoint.Y) - center).Magnitude
        <= getgenv().FOV_SIZE
end

local function isValidTarget(char)
    local hum = char:FindFirstChildOfClass('Humanoid')
    if not hum or hum.Health <= 0 then
        return false
    end
    if char:FindFirstChildWhichIsA('ForceField') then
        return false
    end
    return true
end

local function findBestTarget()
    local closest, dist = nil, math.huge
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= player and plr.Character and isValidTarget(plr.Character) then
            local head = plr.Character:FindFirstChild('Head')
            if head then
                local d = (rootPart.Position - head.Position).Magnitude
                if
                    d < dist
                    and d <= getgenv().MAX_DISTANCE
                    and isInFOV(head.Position)
                then
                    dist, closest = d, head
                end
            end
        end
    end
    return closest
end

local function shootAtTarget(targetHead)
    if not targetHead then
        return
    end
    local headPos = targetHead.Position
    local dir = (headPos - rootPart.Position).Unit
    pcall(function()
        REGunRemote:FireServer(
            'Shoot',
            targetHead,
            headPos,
            dir,
            Enum.Material.Plastic
        )
    end)
    makeBeam(rootPart.Position, headPos, Color3.fromRGB(0, 255, 0))
end

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then
        return
    end
    if input.KeyCode == Enum.KeyCode.J then
        getgenv().AUTO_SHOOT = not getgenv().AUTO_SHOOT
    elseif input.KeyCode == Enum.KeyCode.RightShift then
        getgenv().FOV_VISIBLE = not getgenv().FOV_VISIBLE
    end
end)

task.spawn(function()
    while true do
        if getgenv().AUTO_SHOOT and rootPart and character then
            local tgt = findBestTarget()
            if tgt then
                shootAtTarget(tgt)
                task.wait(getgenv().AUTO_SHOOT_RATE)
            else
                task.wait(0.2)
            end
        else
            task.wait(0.1)
        end
    end
end)

task.defer(function()
    repeat
        task.wait()
    until UI and UI.Tabs and UI.Tabs.Combat

    UI.Sections.RageShoot:Header({ Name = 'RageShot Options' })

    UI.Sections.RageShoot:Toggle({
        Name = 'Enable Rage Shot',
        Default = false,
        Callback = function(value)
            getgenv().AUTO_SHOOT = value
        end,
    }, 'RageShotToggle')

    UI.Sections.RageShoot:Toggle({
        Name = 'Show FOV Circle',
        Default = false,
        Callback = function(value)
            getgenv().FOV_VISIBLE = value
        end,
    }, 'FOVVisibleToggle')

    UI.Sections.RageShoot:Slider({
        Name = 'FOV Radius',
        Default = getgenv().FOV_SIZE,
        Minimum = 50,
        Maximum = 500,
        DisplayMethod = 'Value',
        Precision = 0,
        Callback = function(value)
            getgenv().FOV_SIZE = value
            if fovCircle then
                fovCircle.Radius = value
            end
        end,
    }, 'FOVRadiusSlider')

    UI.Sections.RageShoot:Slider({
        Name = 'Range (Max Distance)',
        Default = getgenv().MAX_DISTANCE,
        Minimum = 100,
        Maximum = 1000,
        DisplayMethod = 'Value',
        Precision = 0,
        Callback = function(value)
            getgenv().MAX_DISTANCE = value
        end,
    }, 'RangeSlider')
end)

task.defer(function()
    repeat
        task.wait()
    until UI and UI.Tabs and UI.Tabs.Troll

    UI.Sections.Vehicle:Header({ Name = 'Vehicle Troller' })

    UI.Sections.Vehicle:Toggle({
        Name = 'Enable Vehicle Gui',
        Default = false,
        Callback = function(value)
            if value then
                if not getgenv().SYLLINSE_GUI then
                    -- // Setup Vehicle GUI
                    local Players = game:GetService('Players')
                    local RunService = game:GetService('RunService')
                    local LocalPlayer = Players.LocalPlayer
                    local ps = LocalPlayer:WaitForChild('PlayerScripts')
                    local BindToCar = ps:WaitForChild('DestructionHandler')
                        :WaitForChild('BindToCar')
                    local CarsFolder = workspace:WaitForChild('Cars')

                    local char, hrp
                    local function updateCharacter()
                        char = LocalPlayer.Character
                            or LocalPlayer.CharacterAdded:Wait()
                        hrp = char:WaitForChild('HumanoidRootPart')
                    end
                    updateCharacter()
                    LocalPlayer.CharacterAdded:Connect(updateCharacter)

                    local ScreenGui = Instance.new('ScreenGui')
                    ScreenGui.Name = 'SYLLINSE_GUI'
                    ScreenGui.ResetOnSpawn = false
                    ScreenGui.Parent = game:GetService('CoreGui')
                    getgenv().SYLLINSE_GUI = ScreenGui

                    local Frame = Instance.new('Frame')
                    Frame.Size = UDim2.new(0, 320, 0, 270)
                    Frame.Position = UDim2.new(0.3, 0, 0.3, 0)
                    Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                    Frame.BorderColor3 = Color3.fromRGB(255, 255, 255)
                    Frame.BorderSizePixel = 2
                    Frame.Active = true
                    Frame.Draggable = true
                    Frame.Parent = ScreenGui

                    local FrameCorner = Instance.new('UICorner')
                    FrameCorner.CornerRadius = UDim.new(0, 10)
                    FrameCorner.Parent = Frame

                    local Title = Instance.new('TextLabel')
                    Title.Size = UDim2.new(1, 0, 0, 45)
                    Title.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                    Title.Text = 'SYLLINSE'
                    Title.TextColor3 = Color3.new(1, 1, 1)
                    Title.TextScaled = true
                    Title.Font = Enum.Font.GothamBold
                    Title.Parent = Frame

                    local PlayerDropdown = Instance.new('TextButton')
                    PlayerDropdown.Size = UDim2.new(0.9, 0, 0, 35)
                    PlayerDropdown.Position = UDim2.new(0.05, 0, 0.25, 0)
                    PlayerDropdown.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
                    PlayerDropdown.TextColor3 = Color3.new(1, 1, 1)
                    PlayerDropdown.Text = 'SELECT PLAYER'
                    PlayerDropdown.Font = Enum.Font.Gotham
                    PlayerDropdown.TextSize = 14
                    PlayerDropdown.Parent = Frame

                    local DropdownCorner = Instance.new('UICorner')
                    DropdownCorner.CornerRadius = UDim.new(0, 6)
                    DropdownCorner.Parent = PlayerDropdown

                    local HijackBtn = Instance.new('TextButton')
                    HijackBtn.Size = UDim2.new(0.4, 0, 0, 50)
                    HijackBtn.Position = UDim2.new(0.05, 0, 0.55, 0)
                    HijackBtn.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                    HijackBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
                    HijackBtn.Text = 'HIJACK'
                    HijackBtn.Font = Enum.Font.GothamBold
                    HijackBtn.TextSize = 16
                    HijackBtn.Parent = Frame

                    local HijackCorner = Instance.new('UICorner')
                    HijackCorner.CornerRadius = UDim.new(0, 6)
                    HijackCorner.Parent = HijackBtn

                    local FlingBtn = Instance.new('TextButton')
                    FlingBtn.Size = UDim2.new(0.4, 0, 0, 50)
                    FlingBtn.Position = UDim2.new(0.55, 0, 0.55, 0)
                    FlingBtn.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                    FlingBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
                    FlingBtn.Text = 'FLING'
                    FlingBtn.Font = Enum.Font.GothamBold
                    FlingBtn.TextSize = 16
                    FlingBtn.Parent = Frame

                    local FlingCorner = Instance.new('UICorner')
                    FlingCorner.CornerRadius = UDim.new(0, 6)
                    FlingCorner.Parent = FlingBtn

                    local StopBtn = Instance.new('TextButton')
                    StopBtn.Size = UDim2.new(0.4, 0, 0, 40)
                    StopBtn.Position = UDim2.new(0.05, 0, 0.75, 0)
                    StopBtn.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                    StopBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
                    StopBtn.Text = 'STOP FLING'
                    StopBtn.Font = Enum.Font.GothamBold
                    StopBtn.TextSize = 14
                    StopBtn.Parent = Frame

                    local StopCorner = Instance.new('UICorner')
                    StopCorner.CornerRadius = UDim.new(0, 6)
                    StopCorner.Parent = StopBtn

                    local CloseBtn = Instance.new('TextButton')
                    CloseBtn.Size = UDim2.new(0.4, 0, 0, 40)
                    CloseBtn.Position = UDim2.new(0.55, 0, 0.75, 0)
                    CloseBtn.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                    CloseBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
                    CloseBtn.Text = 'CLOSE'
                    CloseBtn.Font = Enum.Font.GothamBold
                    CloseBtn.TextSize = 14
                    CloseBtn.Parent = Frame

                    local CloseCorner = Instance.new('UICorner')
                    CloseCorner.CornerRadius = UDim.new(0, 6)
                    CloseCorner.Parent = CloseBtn

                    local StatusLabel = Instance.new('TextLabel')
                    StatusLabel.Size = UDim2.new(0.9, 0, 0, 25)
                    StatusLabel.Position = UDim2.new(0.05, 0, 0.9, 0)
                    StatusLabel.BackgroundTransparency = 1
                    StatusLabel.TextColor3 = Color3.new(1, 1, 1)
                    StatusLabel.Text = 'READY'
                    StatusLabel.Font = Enum.Font.Gotham
                    StatusLabel.TextSize = 12
                    StatusLabel.Parent = Frame

                    local SelectedPlayer
                    local flingLoop

                    local function findSeatInCar(car)
                        return car:FindFirstChildWhichIsA('VehicleSeat', true)
                            or car:FindFirstChildWhichIsA('Seat', true)
                    end

                    local function sitInSeat(seat)
                        local humanoid = char:FindFirstChildOfClass('Humanoid')
                        if humanoid then
                            humanoid.Sit = false
                            task.wait()
                            seat:Sit(humanoid)
                        end
                    end

                    local function findNearestCar()
                        local bestCar, bestSeat, bestDist
                        for _, car in pairs(CarsFolder:GetChildren()) do
                            if car:IsA('Model') then
                                local seat = findSeatInCar(car)
                                if seat and not seat.Occupant then
                                    local dist = (seat.Position - hrp.Position).Magnitude
                                    if not bestDist or dist < bestDist then
                                        bestDist = dist
                                        bestCar = car
                                        bestSeat = seat
                                    end
                                end
                            end
                        end
                        return bestCar, bestSeat
                    end

                    local function tpAndBind(car, seat)
                        hrp.CFrame = seat.CFrame + Vector3.new(0, 2, 0)
                        task.wait(0.2)
                        sitInSeat(seat)
                        task.wait(0.2)
                        BindToCar:Fire(car, function() end)
                    end

                    local function getMyCar()
                        local humanoid = char:FindFirstChildOfClass('Humanoid')
                        if humanoid and humanoid.SeatPart then
                            return humanoid.SeatPart:FindFirstAncestorWhichIsA(
                                'Model'
                            )
                        end
                        return nil
                    end

                    local function flingPlayer(targetPlayer)
                        if flingLoop then
                            flingLoop:Disconnect()
                            flingLoop = nil
                        end

                        local car = getMyCar()
                        if not car or not car.PrimaryPart then
                            StatusLabel.Text = 'NO CAR FOUND'
                            return
                        end

                        StatusLabel.Text = 'FLINGING: ' .. targetPlayer.Name
                        flingLoop = RunService.Heartbeat:Connect(function()
                            if
                                not targetPlayer.Character
                                or not targetPlayer.Character:FindFirstChild(
                                    'HumanoidRootPart'
                                )
                            then
                                return
                            end
                            local targetHRP =
                                targetPlayer.Character.HumanoidRootPart
                            local dir = (
                                targetHRP.Position - car.PrimaryPart.Position
                            ).Unit
                            car.PrimaryPart.AssemblyLinearVelocity = dir * 700
                                + Vector3.new(0, 300, 0)
                            car.PrimaryPart.AssemblyAngularVelocity =
                                Vector3.new(100, 100, 100)
                            car:PivotTo(targetHRP.CFrame + Vector3.new(0, 5, 0))
                        end)
                    end

                    HijackBtn.MouseButton1Click:Connect(function()
                        local car, seat = findNearestCar()
                        if car and seat then
                            tpAndBind(car, seat)
                            StatusLabel.Text = 'CAR HIJACKED'
                        else
                            StatusLabel.Text = 'NO CAR FOUND'
                        end
                    end)

                    FlingBtn.MouseButton1Click:Connect(function()
                        if SelectedPlayer then
                            flingPlayer(SelectedPlayer)
                        else
                            StatusLabel.Text = 'NO PLAYER SELECTED'
                        end
                    end)

                    StopBtn.MouseButton1Click:Connect(function()
                        if flingLoop then
                            flingLoop:Disconnect()
                            flingLoop = nil
                            StatusLabel.Text = 'FLING STOPPED'
                        else
                            StatusLabel.Text = 'NO FLING ACTIVE'
                        end
                    end)

                    CloseBtn.MouseButton1Click:Connect(function()
                        ScreenGui:Destroy()
                        getgenv().SYLLINSE_GUI = nil
                    end)

                    PlayerDropdown.MouseButton1Click:Connect(function()
                        local dropdown = Instance.new('Frame')
                        dropdown.Size = UDim2.new(0.9, 0, 0, 150)
                        dropdown.Position = UDim2.new(0.05, 0, 0.45, 0)
                        dropdown.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
                        dropdown.BorderColor3 = Color3.fromRGB(255, 255, 255)
                        dropdown.BorderSizePixel = 1
                        dropdown.Parent = Frame

                        local dropdownCorner = Instance.new('UICorner')
                        dropdownCorner.CornerRadius = UDim.new(0, 6)
                        dropdownCorner.Parent = dropdown

                        local scroll = Instance.new('ScrollingFrame')
                        scroll.Size = UDim2.new(1, 0, 1, 0)
                        scroll.BackgroundTransparency = 1
                        scroll.ScrollBarThickness = 4
                        scroll.Parent = dropdown

                        local layout = Instance.new('UIListLayout')
                        layout.Parent = scroll

                        for _, plr in pairs(Players:GetPlayers()) do
                            if plr ~= LocalPlayer then
                                local btn = Instance.new('TextButton')
                                btn.Size = UDim2.new(1, -10, 0, 30)
                                btn.Position = UDim2.new(0, 5, 0, 0)
                                btn.BackgroundColor3 =
                                    Color3.fromRGB(40, 40, 40)
                                btn.TextColor3 = Color3.new(1, 1, 1)
                                btn.Text = plr.Name
                                btn.Font = Enum.Font.Gotham
                                btn.TextSize = 12
                                btn.Parent = scroll

                                local btnCorner = Instance.new('UICorner')
                                btnCorner.CornerRadius = UDim.new(0, 4)
                                btnCorner.Parent = btn

                                btn.MouseButton1Click:Connect(function()
                                    SelectedPlayer = plr
                                    PlayerDropdown.Text = 'TARGET: ' .. plr.Name
                                    dropdown:Destroy()
                                    StatusLabel.Text = 'TARGET SELECTED'
                                end)
                            end
                        end
                        scroll.CanvasSize =
                            UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y)
                    end)
                else
                    getgenv().SYLLINSE_GUI.Enabled = true
                end
            else
                if getgenv().SYLLINSE_GUI then
                    getgenv().SYLLINSE_GUI.Enabled = false
                end
            end
        end,
    }, 'VehicleGuiToggle')
end)
